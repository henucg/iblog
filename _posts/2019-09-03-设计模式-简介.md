---
layout: post
title:  "设计模式-简介"
date:   2019-09-03 15:00:00 +0800
categories: 博客
tags: 设计模式
excerpt: "设计模式的七个原则与三大分类"
---

## 1、什么是设计模式
+ 设计模式（Design Pattern）是前辈们对代码开发经验的总结，是解决特定问题的一系列套路。
+ 它不是语法规定，也不是代码规范，而是一套用来提高代码可复用性、可维护性、可读性、稳健性以及安全性的解决方案
+ 1995 年，GoF（Gang of Four，四人组/四人帮）合作出版了《设计模式：可复用面向对象软件的基础》一书，共收录了23种设计模式，从此树立了软件设计模式领域的里程碑，人称「GoF设计模式」

## 2、设计模式的七大原则
+ 总原则：开闭原则（OCP）
    + 概念：
        + 软件实体（模块、类、方法函数）应该可扩展，但不可修改，即对扩展开放，对修改关闭
    + 作用：
        + 对软件测试的作用：软件测试只需要对扩展的代码进行测试，不需要关注原有的代码
        + 提高程序可复用性：程序粒度越小，越有可能被复用，根据抽象变成，可以提高程序复用性
        + 提高程序可维护性：遵守开闭原则的程序稳定性高，延续性强
    + 实现方式：
        + 通过接口或抽象类定义一个稳定的抽象层，可变因素封装在实现类中
+ 单一职责原则（SRP）
    + 概念：
        + 不要存在多个导致类改变的原因，也就是说一个类只实现单一的功能职责，如若不然，应当拆分
    + 如果一个类实现太多职责，会有几个问题：
        + 一个职责变化可能削弱或抑制这个类实现其它职责的能力
        + 当客户端需要某个职责的时候，不得不将其它不需要的职责全部包含进来，代码冗余
    + 作用：
        + 降低类的复杂度
        + 提高可读性
        + 提高可维护性
        + 降低变更引起的风险
    + 实现方式：
        + 控制类的粒度大小、降低耦合、提高内聚           
+ 里氏替换原则（LSP）：
    + 概念：
        + 继承类必须能确保父类的方法在子类能正确实现
        + 子类可以扩展父类的功能，但不能修改父类的功能
    + 作用：
        + 里氏替换原则是实现开闭原则的重要方式之一  
        + 类的扩展不会给已有的系统引入新的错误，降低了代码出错的可能性
    + 实现方式：
        + 继承父类，如果父类修改导致子类出现问题，重新设计它们之间的关系      
+ 依赖倒置原则（DIP）
    + 概念：
        + 高层模块不应该依赖低层模块，抽象不应该依赖具体实现
    + 作用：
        + 降低类之间的耦合性
        + 提高系统的稳定性
        + 减少并行开发引起的风险
        + 提高程序可读性和可维护性 
    + 实现方式：
        + 每个类尽量提供接口或抽象类
        + 变量的声明类型尽量是接口或抽象类
        + 任何类都不应该从具体类派生
        + 使用继承的时候尽量遵循里氏替换原则       
+ 合成/聚合复用原则（CARP）
    + 概念：
        + 合成复用原则是通过将已有的对象纳入新对象中，作为新对象的成员对象来实现的，新对象可以调用已有对象的功能，从而达到复用
        + 复用通常包括：继承复用或合成复用
    + 继承复用特点：
        + 继承复用破坏了父类的封装性：父类实现直接暴露给了子类
        + 继承复用子类与父类耦合度高：父类改变会导致子类改变，不利于类的扩展与维护
        + 继承复用限制类复用的灵活性：从父类继承而来的是静态的，编译的时候已经确定好，不能改变
    + 合成复用特点：
        + 合成复用将已有对象纳入新对象中，使之成为新对象的一部分，新对象可以调用已有对象的功能
        + 合成复用维持类的封装性
        + 合成复用新旧类之间的耦合度降低
        + 合成复用复用灵活性降低
    + 实现方式：
        + 合成复用将一个类作为另一个类的属性，例如：轮子类可以作为汽车类的一个属性
+ 接口隔离原则（ISP）
    + 概念：
        + 每个接口不存在子类用不到但又必须实现的方法
    + 作用：
        + 将庞大的接口拆成粒度较小的接口，可预防外来变更的扩散，提高系统的灵活性和可维护性
        + 提高内聚，降低耦合
        + 如果接口的粒度大小定义合理，能够保证系统的稳定性；但是，如果定义过小，则会造成接口数量过多，使设计复杂化；如果定义太大，灵活性降低，无法提供定制服务，给整体项目带来无法预料的风险
        + 使用多个专门的接口还能够体现对象的层次，因为可以通过接口的继承，实现对总接口的定义
        + 能减少项目工程中的代码冗余
    + 实现方式：
        + 接口尽量小，但是要有限度
        + 为依赖接口的类定制服务。只提供调用者需要的方法，屏蔽不需要的方法
        + 了解环境，找到适合自己系统的拆分粒度
        + 提高内聚力，减少对外交互        
+ 最少知道原则（LKP）/迪米特法则(LOD)
    + 概念：
        + 如果两个软件实体无须直接通信，那么就不应当发生直接的相互调用，可以通过第三方转发该调用。其目的是降低类之间的耦合度，提高模块的相对独立性
        + 一个类对自己依赖的类知道的越少越好，被依赖的类只需要将结果返回给别人即可，而具体的实现不需要告诉别人
    + 作用：
        + 降低类之间的耦合度，提高模块之间的独立性
        + 提高类的复用性和可扩展性
    + 实现方式：
        + 从依赖者角度：只依赖需要依赖的对象
        + 从被依赖者角度：只暴露应该暴露的对象
## 3、设计模式的三大分类
+ 创建型模式（5种）：
    + 单例模式
    + 工厂方法模式
    + 抽象工厂模式
    + 建造者模式
    + 原型模式
+ 结构性模式（7种）：
    + 适配器模式
    + 装饰器模式
    + 代理模式
    + 外观模式
    + 桥接模式
    + 组合模式
    + 享元模式
+ 行为性模式（11种）：
    + 策略模式
    + 模板方法模式
    + 观察者模式
    + 迭代子模式
    + 责任链模式
    + 命令模式
    + 备忘录模式
    + 状态模式
    + 访问者模式
    + 中介者模式
    + 解释器模式
    
## 4、参考
+ http://c.biancheng.net/design_pattern/