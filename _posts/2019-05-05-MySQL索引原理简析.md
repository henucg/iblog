---
layout: post
title:  "MySQL索引原理简析"
date:   2019-05-05 22:43:00 +0800
categories: 博客
tags: 数据库
excerpt: "简析MySQL索引底层数据结构以及优化方案"
---


## 1、概述  
简析MySQL索引底层数据结构以及优化方案

## 2、IO操作  
+ CPU读取数据先从内存中读取，如果内存中没有则直接去硬盘中读取，CPU一次从硬盘中读取的数据大小为4K（计算机组成原理设定）
+ CPU从磁盘中读取数据分两步：
   + 寻道，比较耗时
   + 旋转，比较块
+ 以上两步成为一次IO操作，一次IO操作不仅会找到目标数据，还会查询出目标数据相邻的其他数据（计算机组成原理局部性原理）
+ 索引的目的就是为了减少IO操作

## 2、索引结构

#### 1.二叉树：  
   + 可能导致单向链表，同时树的高度可能会很高，不采用

#### 2.Hash：  
   + 根据计算出的Hash值，能快速定位到一条数据，但是没有解决Hash碰撞，也不能解决范围查找的问题，
   + 在MYSQL中处于可选状态，一般不采用

#### 3.B-Tree：  
   + 度：节点内存储数据的最大个数，达到最大个数的15/16的之后开始分叉
   + 叶子节点都有相同的深度，且指针为空
   + 节点数据key从左至右一次递增
   + 节点内的数据比较都在内存中进行，速度非常快，每一次IO操作都会将一个节点的数据全部加载到内存当中，但是节点的数据个数（度）不能一味的横向扩张，MySQL设计的节点的度的大小为CPU一次能从硬盘中读取数据的最大值，即为4K，这样能保证每一次IO操作都能将一个节点的数据全部读取到内存
   + B-Tree的节点不仅会存储索引值，而且会存储表中的真实数据，这就导致一个问题，节点的最大值一般为4K，既要存储索引数据，又要存储真实数据，必然会导致存储的索引个数变少，即树的度会变小，树的高度也随之而增加，IO操作次数增加，所以在MySQL的底层数据结构中并没有采用B-Tree

#### 4.B+Tree：
   + B+Tree是B-Tree的变种
   + B+Tree与B-Tree最大的区别是：B+Tree的非叶子节点不存储 真实的数据，只存储索引数据，所有的真实数据都存储在叶子节点中，每次查找都会索引到叶子节点才能找到所需要的数据；第二个区别就是：每个叶子节点之间有一个顺序的指针
   + B-Tree相对于B+Tree的优势是不用每次都查询到叶子节点    
   + 每新建一个索引，都相当于新建一个B+Tree
   + MySQL底层数据结构采用的是B+Tree

## 3、B+Tree的性能分析
   + IO的次数是评价索引结构优劣的标准
   + 预读：一次IO操作一半会顺序读取一定长度的数据（一般为4K，为页的整倍数）放入内存
   + 局部性原理：当一个数据被用到，通常它附近的数据也会很快被用到
   + B+Tree节点大小设定为4K（一个页），每次新建节点都会申请一个页大小的空间，这就保证了一个节点在物理上也存在一个页里面，就实现了一个节点的载入只需要一次IO操作
   + B+Tree的度一般会超过100，因此高度很低，一般在3～5之间 

## 5、MYSQL存储引擎

#### 1.MyISAM：
   + 非聚集索引：叶子节点不存储真实的数据，只存储索引数据和真实数据的文件指针（地址），每次查询都会先从树里面查到文件指针，再根据指针去查寻到数据，因此至少会有两次IO
   + 主键索引与普通索引一样，都是非聚集的B+Tree  

#### 2.InnoDB：
   + 聚集索引：聚集索引指的是主键索引，聚集索引一定要有主键，因为底层数据就是按主键存储的，推荐使用整型自增主键，这样能保证每次增加数据永远是在叶子节点后面插入，减少比较的次数和分裂
   + InnoDB的主键索引与普通索引是不一样的，主键索引叶子节点既存储索引也存储真实数据，而普通索引叶子节点存储索引，但不存储真实的数据，但会同时存储一个主键的索引，每次查询数据的时候，都会先找到主键索引，然后根据主键索引去找真实的数据，这样做的目的是为了避免建多个索引的时候真实数据会被存储多次，浪费空间，降低增删改的性能，但由于每次都要查找两次，所以InnoDB的普通索引效率并不是很高，一般多用主键索引，少用普通索引

#### 3.MyISAM和InnoDB
   + 二者都是表级别的存储引擎，一个数据库里面的表不一定都是一种存储引擎，MySQL 5.5之前默认引擎是MyISAM，5.5之后默认是InnoDB 

## 6、联合索引以及最左前缀原理

#### 1.联合索引（符合索引）：
   + 如果对一张表的三个字段建立了一个联合索引(col1,col2,col3)，则B+Tree叶子节点存的是这三个字段的索引，并且按照顺序排好 
   ![]({{site.url}}/assets/20190505_01/0.png)

#### 2.最左前缀原理：
   + 例如：在（a,b,c）上建立一个联合索引，则一下查询都可以用到索引  
    `select * from table where a = 1 ;`    
    `select * from table where a = 1 and b = 2 ;`  
    `select * from table where a = 1 and b = 2 and c = 3 ;`  
    上面按照（a）、（a,b）、（a,b,c）的顺序都可以利用到索引，这就是最左前缀匹配
   + 如果查询语句是：  
    `select * from table where a = 1 and c = 3 ;`  
    则只会用到索引（a）,因为c的前缀没有用到
   + 如果查询语句是：  
    `select * from table where b = 2 and c = 3 ;`  
    以为b的前缀a没有被用到，所以这条语句是用不到索引的
   + 如果用到了最左前缀，但是颠倒了顺序：  
    `select * from table where b = 2 and a = 1 ;`  
    `select * from table where c = 3 and a = 1 and b = 2 ;` 
   + 如果只是颠倒了顺序但是用到了最左前缀，也是可以用到索引的，因为MYSQL的查询优化器会自动这条SQL以什么顺序执行效率最高，最后才生成执行计划，但是我们还是按照索引顺序来查询，这样查询优化器就不会重新编译了

#### 3.前缀索引：模糊查询  
   + 如果SQL语句是：   
   `select * from table where a like 'xxx%' ;`  
   此时a是走索引的
   + 如果SQL语句是：   
   `select * from table where a like '%xxx%' ;`  
   此时a是不走索引的
   + MYSQL的前缀索引能有效减小索引文件的大小，提高索引速度，但前缀索引也有他的坏处，MySQL不能在ORDER BY和GROUP BY中使用索引 

## 7、索引优化
+ 最左前缀匹配原则
+ 主键外键一定要建索引
+ 对where、on、order by、group by中出现的字段建索引
+ 尽量选择区分度比较高的列建索引，区分度公式：count(distinct 列)/count(*)，表示字段不重复的比例，比例越大我们扫描的记录越少，唯一键的区分度为1，而一些状态，性别区分度可能就是0
+ 对较小的列使用索引，这样索引的文件更小，内存中也能装载更多索引键
+ 索引列不能参与计算，因为索引建立的B+Tree是为列数据的原值而建立的，计算之后值被修改，索引失效
+ 为较长的字段使用前缀索引
+ 尽量扩展索引，而不是新建索引，例如：如果表中已经存在（a）的索引，现在需要（a,b）的索引，只需要修改原来的索引即可
+ 不要过多创建索引，权衡索引个数与DML（insert、delete）效率之间的关系
+ 对于like查询，like 'xxx%' 走索引，而like '%xxx%'不走索引
+ where查询条件数据类型不配也不能使用索引
+ 字符串与数字比较不走索引
+ 以上优化规则并不一定需要，要根据实际情况从优设计