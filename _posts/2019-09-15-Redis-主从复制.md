---
layout: post
title:  "Redis-主从复制"
date:   2019-09-15 22:30:00 +0800
categories: 博客
tags: NOSQL
excerpt: "Redis主从复制的几种模式介绍"
---

## 1、Redis主从复制
+ 概念：主机数据更新后根据配置和策略，自动同步到备机的master/slaver机制，Master以写为主，Slave以读为主
+ 复制原理：
	+ master接到命令启动后台的存盘进程，同时收集所有接收到的用于修改数据集命令，在后台进程执行完毕之后，master将传送整个数据文件到slave,以完成一次完全同步
	+ 全量复制：而slave服务在接收到数据库文件数据后，将其存盘并加载到内存中
	+ 增量复制：master继续将新的所有收集到的修改命令依次传给slave,完成同步
	+ 但是只要是重新连接master,一次完全同步（全量复制)将被自动执行

## 2、作用
+ 读写分离
+ 容灾恢复

## 3、配置原则
+ 配从(库)不配主(库)
+ 从库配置：slaveof 主库IP 主库端口，每次与master断开之后，都需要重新连接，除非你配置进redis.conf文件
+ 查看服务角色与主从信息：info replication

## 4、配置文件休要修改的细节
+ 在这里我在一台机器上启动了三个Redis服务：
	+ 127.0.0.1:6379
	+ 127.0.0.1:6380
	+ 127.0.0.1:6381
+ 对应三个配置文件：redis_6379.conf、redis_6380.conf、redis_6381.conf，分别修改各自的配置文件（以6379为例）：
	+ 开启守护进程：daemonize yes	
	+ 修改端口号：port 6379
	+ 修改PID文件名称：pidfile /var/run/redis_6379.pid
	+ 修改日志文件名称：logfile 6379_log
	+ 修改RDB文件名称：dbfilename dump_6379.rdb 
+ 分别启动： 
	+ 窗口1
```java
> cd /home/redis-4.0.14/
redis-4.0.14>  redis-server redis_6379.conf
redis-4.0.14>  redis-cli -p 6379
127.0.0.1:6379> ping
PONG
```

	+ 窗口2
```java	
> cd /home/redis-4.0.14/
redis-4.0.14>  redis-server redis_6380.conf
redis-4.0.14>  redis-cli -p 6380
127.0.0.1:6380> ping
PONG
```

	+ 窗口3
```java	
> cd /home/redis-4.0.14/
redis-4.0.14>  redis-server redis_6381.conf
redis-4.0.14>  redis-cli -p 6381
127.0.0.1:6381> ping
PONG
```

## 5、一主多二模式
+ 以6379为主，6380和6381为从
+ 窗口1
```java
127.0.0.1:6379> info replication
# Replication
role:master
connected_slaves:2
slave0:ip=127.0.0.1,port=6381,state=online,offset=2226,lag=0
slave1:ip=127.0.0.1,port=6380,state=online,offset=2226,lag=0
master_replid:a55c209648a0848939dfc5b9983ecdb7188c692c
master_replid2:0000000000000000000000000000000000000000
master_repl_offset:2226
second_repl_offset:-1
repl_backlog_active:1
repl_backlog_size:1048576
repl_backlog_first_byte_offset:1
repl_backlog_histlen:2226
```

+ 窗口2
```java	
127.0.0.1:6380> slaveof 127.0.0.1 6379
OK
127.0.0.1:6380> info replication
# Replication
role:slave
master_host:127.0.0.1
master_port:6379
master_link_status:up
master_last_io_seconds_ago:5
master_sync_in_progress:0
slave_repl_offset:28
slave_priority:100
slave_read_only:1
connected_slaves:0
master_replid:a55c209648a0848939dfc5b9983ecdb7188c692c
master_replid2:0000000000000000000000000000000000000000
master_repl_offset:28
second_repl_offset:-1
repl_backlog_active:1
repl_backlog_size:1048576
repl_backlog_first_byte_offset:15
repl_backlog_histlen:14
```

+ 窗口3
```java	
127.0.0.1:6381> slaveof 127.0.0.1 6379
OK
127.0.0.1:6381> info replication
# Replication
role:slave
master_host:127.0.0.1
master_port:6379
master_link_status:up
master_last_io_seconds_ago:3
master_sync_in_progress:0
slave_repl_offset:2184
slave_priority:100
slave_read_only:1
connected_slaves:0
master_replid:a55c209648a0848939dfc5b9983ecdb7188c692c
master_replid2:0000000000000000000000000000000000000000
master_repl_offset:2184
second_repl_offset:-1
repl_backlog_active:1
repl_backlog_size:1048576
repl_backlog_first_byte_offset:1
repl_backlog_histlen:2184
```
+ 只有主机能执行写操作，从机只能进行读操作
+ 主从复制的时候首次复制主机所有数据，之后增量复制
+ 主机宕机之后从机数据还在，角色不变，与主机的连接状态变为down
+ 主机恢复之后，主从关系不变
+ 从机宕机恢复之后从机数据还在，主从关系解散，需要从新设置主从关系，如果不想每次都从新设置，可以配置到配置文件里面

## 6、传递模式
+ 以6379为主，6380作为6379的从机，同时6381作为6380的从机
+ 此时6379的角色为：master，其它仍为：slave
+ 中途变更转向:会清除之前的数据，重新建立拷贝最新的
+ 具体操作以及结果不在展示

## 7、反客为主模式
+ 设置6380为新的主机：
	+ 窗口2：
```java
slaveof no one
```
	+ 窗口3：
```java
slave 127.0.0.1 6380
```	
+ 此时原主机6379与6380、6381没有任何关系

## 8、哨兵模式
+ 客为主的自动版，能够后台监控主机是否故障，如果故障了根据投票数自动将从库转换为主库、而不需要人为指定新的主从关系
+ 配置文件：sentinel.conf文件，名字绝不能错
+ 配置内容：

```sh
sentinel monitor <master-name> <ip> <redis-port> <quorum>

# 例如：sentinel monitor mymaster 127.0.0.1 6379 1
# <master-name>：
# <ip>：主机IP
# <redis-port>：主机端口
# <quorum>：意思是至少有 quorum 个sentinel主观的认为这个master有故障，才会对这个master进行下线以及故障转移。因为有的时候，
#  某个sentinel节点可能因为自身网络原因，导致无法连接master，而此时master并没有出现故障，所以这就需要多个sentinel都一致认为该master有问题，
#  才可以进行下一步操作，这就保证了公平性和高可用
```

+ 启动哨兵：redis-sentinel sentinel.conf
![]({{site.url}}/assets/20190915_06/0.png){:width="100%"}
	+ 第1步：表示哨兵启动成功
	+ 第2部：6379被我SHUTDOWN，哨兵监控到主机挂掉
	+ 第3部：投票选举出6381为新的主机
+ 一组sentinel能同时监控多个Master
+ 主机宕机之后，从机投票选举出新的主机，并建立新的主从关系，原主机重新启动之后，与新主从没有任何关系，角色是master，后面被哨兵监控到之后变成新主机的从机，建立关系，角色为slave
+ 我在这篇文章中演示的时候是在一台机器上启动三个Redis实例，所以只启动了一个哨兵就可以监控三个Redis实例，如果3个Redis粉笔部署在3台机器上，那么就需要同时启动三个哨兵，它们配置一样，不仅可以监控Redis服务，还可以相互监控
+ 哨兵和Redis服务是两个进程，Redis服务停止不会影响哨兵运行
+ 一般sentinel采取奇数台，防止某一台sentinel无法连接到master导致误切换

## 9、主从复制优缺点
+ 优点：一定程度上保证数据完整性
+ 缺点：主从复制存在延时
