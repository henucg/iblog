---
layout: post
title:  "IO-常见的IO模型"
date:   2019-10-06 10:00:00 +0800
categories: 博客
tags: IO
excerpt: "IO的基本原理以及常见的五种IO模型"
---

## 1、IO分类
+ 磁盘IO
	+ 寻道，时间较长
    + 旋转，时间较短
+ 网络IO：Socket读写
    + 将数据从磁盘加载到内核空间（缓冲区），等待数据准备完成，时间较长
    + 将数据从内核空间复制到用户空间的进程内存中，时间较短
+ 这里我们主要讲的是网络IO

## 2、网络IO的主要请求流程
+ 如图：
![]({{site.url}}/assets/20191006_01/0.png){:width="100%"}  
+ 1、请求到达应用层
+ 2、nginx用户进程向内核请求资源
+ 3、内核读取磁盘数据
+ 4、内核将磁盘数据拷贝到内核缓冲区，这一步比较耗时
+ 5、内核将数据从内核缓冲区拷贝到用户进程缓冲区（或者应用程序内存缓冲区）
+ 7、应用程序将结果包装返回

## 3、2组基本概念
+ 同步/异步：关注的是消息的通知机制
	+ 同步：调用者等待被调用者返回结果之后再执行其它操作，等待期间不断去询问获得结果
    + 异步：被调用者通过状态、通知、回调机制主动通知调用者运行状态
+ 阻塞/非阻塞：关注的是调用者在等待返回结果前的执行的状态
	+ 阻塞：调用者被挂起
    + 非阻塞：调用者不挂起

## 4、常见的五种IO模型
+ 同步阻塞IO模型
+ 同步非阻塞IO模型
+ IO多路复用模型
+ 信号驱动模型
+ 异步IO模型 

## 5、同步阻塞IO模型
+ 如图：
![]({{site.url}}/assets/20191006_01/1.png){:width="100%"}
+ recvform是内核的一个系统调用
+ 同步阻塞IO模型是最简单的IO模型，用户线程在内核进行IO操作时被阻塞
+ 用户线程通过系统调用read发起IO请求，由用户空间转到内核空间，内核等到请求的数据到达之后，然后将接收到的数据拷贝到用户空间，完成read操作
+ 用户需要等待内核将数据拷贝到用户空间之后才继续处理接收到的数据
+ 整个请求过程过程中，用户线程是被阻塞的，这导致用户在发起IO请求时，不能做任何事情，CPU利用率不高   

## 6、同步非阻塞IO模型
+ 如图：
![]({{site.url}}/assets/20191006_01/2.png){:width="100%"}  
+ 用户发起IO请求时立即返回，但并未读取到任何数据，用户线程需要不断发起IO请求，直到数据到达之后，才真正读取到数据，继续执行。即"轮询"机制
+ 这个IO请求过程中，虽然用户线程每次发起IO请求之后就会立即返回，但是为了得到数据，仍然需要不断轮询操作、重复请求，消耗大量CPU资源
+ 是比较浪费CPU的方式，一般很少使用这种模式，而是在其它模式中使用非阻塞IO这一特性  

## 7、IO多路复用模型
+ 如图：
![]({{site.url}}/assets/20191006_01/3.png){:width="100%"}    
+ 多个连接共用一个连接机制select，该模型会阻塞进程，但是进程是阻塞在select或者poll这两个系统调用上，而不是阻塞在真正的IO操作上
+ 用户进程首先将需要进行IO的操作添加到select中，然后继续执行其它的工作（异步），同时等待select系统返回调用结果。
当数据到达时，IO被激活，select函数返回，用户线程正式发起read请求，读取数据并继续执行。
+ 从流程上看，使用select函数进行IO请求和同步阻塞模型没有太大的区别，甚至还多添加监视IO，以及调用select函数的额外操作，效率更差。
并且阻塞了两次，但是第一次阻塞在select时，select可以监控多个IO上是否有IO操作准备就绪，即可达到在同一个线程处理多个IO请求的目的。
而不是像阻塞IO那样，一次只能监控一个IO
+ 虽然上述方式允许单线程处理多个IO请求，但是每个IO请求过程还是阻塞的（在select函数上阻塞），因此平均时长甚至同步阻塞IO模型还要长。
如果用户只是注册自己需要的IO请求，然后去做其他的事情，等数据到来再进行处理，则可以提高CPU的利用率
+ IO多路复用模型是最常用的IO模型，但是其异步成都还不够彻底，因为它使用了会阻塞线程的select系统调用，因此IO多路复用只能被称为
异步阻塞IO模型，而非真正的异步IO
+ IO复用是指内核一旦发现进程指定的一个或多个IO准备读取，就通知该进程，IO多路复用适合如下场景：
    + 当客户端处理多个描述符，一般指交互式输入和网络套接口
    + 当一个客户端同时处理多个套接字，这种情况一般很少
    + 当一个TCP服务器既要监听套接字，又要处理已连接套接字
    + 当一个服务器既要连接TCP、又要连接UDP
    + 当一个服务器需要处理多个服务或多个协议

## 8、信号驱动模型
+ 如图：
![]({{site.url}}/assets/20191006_01/4.png){:width="100%"}  
+ 信号量驱动IO：singal-drivenIO
+ 用户进程可以通过sigaction系统调用注册一个信号处理程序，然后主程序可以继续向下执行，当有IO操作准备就绪时，由内核通知触发一个SIGIO信号处理程序，然后将用户进程所需要的数据从内核空间拷贝到用户空间
+ 此模式的优势在于等待数据报到达期间不被阻塞。用户主程序可以继续执行，只要等待来自信号处理函数的通知
+ 该模型并不常用

## 9、异步IO模型  
+ 如图：
![]({{site.url}}/assets/20191006_01/5.png){:width="100%"}    
+ 异步IO与信号量驱动IO最主要的区别是：信号量驱动IO是由内核通知何时可以进行IO操作，而异步IO则是由内核告诉用户线程IO操作何时完成。
信号量IO当内核通知触发信号处理程序时，信号处理程序还需要阻塞在从内核空间缓冲区拷贝数据到用户空间缓冲区这个阶段，而异步IO直接在第二个阶段完成之后由内核通知用户线程可以进行后续操作了
+ 相比IO多路复用模型，异步IO并不十分常用，不少高性能并发服务使用IO多路复用模型+多线程异步处理框架基本可以满足需求，目前操作系统对异步IO的支持
并非特别完善，更多的是用IO多路复用模型模拟异步IO的方式（IO事件触发时不直接通知用户进程，而是直接将数据拷贝到用户空间缓冲区）

## 10、五种IO模型对比
![]({{site.url}}/assets/20191006_01/6.png){:width="100%"}