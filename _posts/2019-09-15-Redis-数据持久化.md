---
layout: post
title:  "Redis-数据持久化"
date:   2019-09-15 19:30:00 +0800
categories: 博客
tags: NOSQL
excerpt: "数据持久化：RDB、AOF"
---

## 1、Redis数据持久化
+ 由于Redis的数据都存放在内存中，如果没有配置持久化，redis重启后数据就全丢失了，于是需要开启redis的持久化功能，将数据保存到磁盘上，当redis重启后，可以从磁盘中恢复数据。
+ redis提供两种方式进行持久化：
	+ 一种是RDB持久化（原理是将Reids在内存中的数据库记录定时dump到磁盘上的RDB持久化）
	+ 另外一种是AOF（append only file）持久化（原理是将Reids的操作日志以追加的方式写入文件）

## 2、RDB

+ 概念：
	+ 在指定的时间间隔内将内存中的数据集快照写入磁盘，也就是行话讲的Snapshot快照，它恢复时是将快照文件直接读到内存里
	+ Redis会单独创建（fork）一个子进程来进行持久化，会先将数据写入到一个临时文件中，待持久化过程都结束了，再用这个临时文件替换上次持久化好的文件。整个过程中，主进程是不进行任何IO操作的，这就确保了极高的性能
	+ 如果需要进行大规模数据的恢复，且对于数据恢复的完整性不是非常敏感，那RDB方式要比AOF方式更加的高效。RDB的缺点是最后一次持久化后的数据可能丢失
	+ fork的作用是复制一个与当前进程一样的进程。新进程的所有数据（变量、环境变量、程序计数器等）数值都和原进程一致，但是是一个全新的进程，并作为原进程的子进程

+ 备份文件：dump.rdb

+ 步骤：
	+ 生成临时文件rdb，并写入数据
	+ 完成写入数据，并用临时文件替换正式的的rdb文件
	+ 删除原来的rdb文件

+ 触发条件：
	+ 达到即配置的条件
```sh
save 900 1：表示900 秒内如果至少有 1 个 key 的值变化，则保存
save 300 10：表示300 秒内如果至少有 10 个 key 的值变化，则保存
save 60 10000：表示60 秒内如果至少有 10000 个 key 的值变化，则保存
# save：这里是用来配置触发 Redis的持久化条件，也就是什么时候将内存中的数据保存到硬盘
# 如果你只是用Redis的缓存功能，不需要持久化，那么你可以注释掉所有的 save 行来停用保存功能。可以直接一个空字符串来实现停用：save ""
#
stop-writes-on-bgsave-error
# 默认值为yes。当启用了RDB且最后一次后台保存数据失败，Redis是否停止接收数据。这会让用户意识到数据没有正确持久化到磁盘上，否则没有人会注意到灾难（disaster）发生了。如果Redis重启了，那么又可以重新开始接收数据了
#
rdbcompression yes
# 默认值是yes。对于存储到磁盘中的快照，可以设置是否进行压缩存储。如果是的话，redis会采用LZF算法进行压缩。如果你不想消耗CPU来进行压缩的话，可以设置为关闭此功能，但是存储在磁盘上的快照会比较大
#
rdbchecksum yes
# 默认值是yes。在存储快照后，我们还可以让redis使用CRC64算法来进行数据校验，但是这样做会增加大约10%的性能消耗，如果希望获取到最大的性能提升，可以关闭此功能
#
dbfilename dump.rdb
# 设置快照的文件名，默认是 dump.rdb
#
dir ./
# 设置快照文件的存放路径，这个配置项一定是个目录，而不能是文件名。使用上面的 dbfilename 作为保存的文件名
```
		+ 这种通过配置文件达到的触发条件，与bgsave类似，会fork一个子进程进行数据持久化操作
		+ 但是这种方式最好不要采用
		+ 因为设置的时间太短会造成频繁持久化，影响服务器性能
		+ 设置的时间太长又会造成数据丢失
	+ save命令
		+ 立即迅速备份，不响应客户端请求
		+ 当客户端向服务端发送save命令时，服务端会阻塞save之后的请求，直到数据持久化完成
		+ 如果数据量太大，持久化时间会很长久，这期间Redis无法接收其它请求，所以一般不在生产环境使用save命令
	+ bgsave命令
		+ 后台备份，同时可以响应客户端请求
		+ 当客户端向服务端发送bgsave命令时，Redis服务主进程会fork一个子进程来进行数据持久化，数据报称到RDB文件之后，子进程退出
		+ 此时主进程仍然可以接收其它请求
		+ 但是fork子进程这个过程是同步的，在fork子进程的过程中，一样不能接收其它请求
		+ 如果fork的过程时间过长，bgsave仍然会阻塞其它请求
	+ flush、flushall、shutdown命令	

+ 恢复：Redis服务重新启动的时候自动加载	

+ 停止：动态所有停止RDB保存规则的方法：redis-cli config set save ""	
	
+ 优点：
	+ rdb文件非常紧凑，适合大规模的数据恢复
	+ 恢复速度快
	+ 通过RDB进行数据备，由于使用子进程生成，所以对Redis服务器性能影响较小

+ 缺点：	
	+ 在一定间隔时间做一次备份，所以如果redis意外down掉的话，就会丢失最后一次快照后的所有修改
	+ 对数据完整性和一致性要求不高
	+ fork的时候，内存中的数据被克隆了一份，大致2倍的膨胀性需要考虑
	+ 使用save命令会造成服务器阻塞，直接数据同步完成才能接收后续请求
	+ 使用bgsave命令在forks子进程时，如果数据量太大，forks的过程也会发生阻塞，另外，forks子进程会耗费内存

## 3、AOF
+ 概念：
	+ 以日志的形式来记录每个写操作，将Redis执行过的所有写指令记录下来(读操作不记录)，
	+ 只许追加文件但不可以改写文件，redis启动之初会读取该文件重新构建数据，换言之，redis重启的话就根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作

+ 配置： 
```sh
appendonly no
# 默认redis使用的是rdb方式持久化，这种方式在许多应用中已经足够用了。但是redis如果中途宕机，会导致可能有几分钟的数据丢失
# 根据save来策略进行持久化，Append Only File是另一种持久化方式，可以提供更好的持久化特性
# Redis会把每次写入的数据在接收后都写入appendonly.aof文件，每次启动时Redis都会先把这个文件的数据读入内存里，先忽略RDB文件
# 默认值为no
#
appendfilename "appendonly.aof"
# aof文件名，默认是"appendonly.aof"
#
# appendfsync always
appendfsync everysec
# appendfsync no
# aof持久化策略的配置；
# no表示不执行fsync，由操作系统保证数据同步到磁盘，速度最快；
# always表示每次写入都执行fsync，以保证数据同步到磁盘；
# everysec表示每秒执行一次fsync，可能会导致丢失这1s数据
#
no-appendfsync-on-rewrite no
# 在aof重写或者写入rdb文件的时候，会执行大量IO，此时对于everysec和always的aof模式来说，执行fsync会造成阻塞过长时间，no-appendfsync-on-rewrite字段设置为默认设置为no
# 如果对延迟要求很高的应用，这个字段可以设置为yes，否则还是设置为no，这样对持久化特性来说这是更安全的选择。  
# 设置为yes表示rewrite期间对新写操作不fsync,暂时存在内存中,等rewrite完成后再写入，默认为no，建议yes
# Linux的默认fsync策略是30秒。可能丢失30秒数据
# 默认值为no
#
auto-aof-rewrite-percentage 100
# 默认值为100
# aof自动重写配置，当目前aof文件大小超过上一次重写的aof文件大小的百分之多少进行重写，即当aof文件增长到一定大小的时候，Redis能够调用bgrewriteaof对日志文件进行重写
# 当前AOF文件大小是上次日志重写得到AOF文件大小的二倍（设置为100）时，自动启动新的日志重写过程
#
auto-aof-rewrite-min-size 64mb
# 64mb。设置允许重写的最小aof文件大小，避免了达到约定百分比但尺寸仍然很小的情况还要重写
# 
aof-load-truncated yes
# aof文件可能在尾部是不完整的，当redis启动的时候，aof文件的数据被载入内存
# 重启可能发生在redis所在的主机操作系统宕机后，尤其在ext4文件系统没有加上data=ordered选项，出现这种现象redis宕机或者异常终止不会造成尾部不完整现象，可以选择让redis退出，或者导入尽可能多的数据
# 如果选择的是yes，当截断的aof文件被导入的时候，会自动发布一个log给客户端然后load
# 如果是no，用户必须手动redis-check-aof修复AOF文件才可以。默认值为 yes
#
aof-use-rdb-preamble no
```

+ 备份文件：appendonly.aof

+ 触发条件：
	+ 配置策略：
		+ appendfsync always 	// 每次写入都执行fsync，以保证数据同步到磁盘
		+ appendfsync everysec 	// 每秒执行一次fsync，可能会导致丢失这1s数据
		+ appendfsync no 		// 不执行fsync，由操作系统保证数据同步到磁盘，速度最快，但是也是最不安全的，不推荐使用

+ 恢复：
	+ 正常恢复：重启redis然后重新加载
	+ 异常恢复：
		+ 备份被写坏的AOF文件
		+ 修复：`redis-check-aof --fix appendonly.aof`，原理是删除不符合Redis语法规则的错误语句
		+ 重启redis然后重新加载

+ 重写（rewrite）机制：
	+ AOF采用文件追加方式，文件会越来越大，为避免出现此种情况，新增了重写机制,当AOF文件的大小超过所设定的阈值时，Redis就会启动AOF文件的内容压缩，只保留可以恢复数据的最小指令集，有两种重写的方式：
	+ 配置文件：`no-appendfsync-on-rewrite no`
		+ 通过在redis.conf配置文件中的选项no-appendfsync-on-rewrite可以设置是否开启重写，这种方式会在每次fsync时都重写，影响服务器性以，因此默认值为no，不推荐使用
	+ bgrewriteaof命令：
		+ AOF文件持续增长而过大时，会fork出一条新进程来将文件重写(也是先写临时文件最后再rename)，遍历新进程的内存中数据，每条记录有一条的Set语句。重写aof文件的操作，并没有读取旧的aof文件，而是将整个内存中的数据库内容用命令的方式重写了一个新的aof文件，这点和快照有点类似
		+ Redis会记录上次重写时的AOF大小，默认配置是当AOF文件大小是上次rewrite后大小的一倍且文件大于64M时触发
	+ 重写的优点：
		+ 压缩aof文件，减少磁盘占用量
		+ 将aof的命令压缩为最小命令集，加快了数据恢复的速度。	

+ 优点：
	+ AOF只是追加日志文件，因此对服务器性能影响较小，速度比RDB要快，消耗的内存较少
	+ 修改同步：`appendfsync always`  同步持久化 每次发生数据变更会被立即记录到磁盘，性能较差但数据完整性比较好
	+ 每秒同步：`appendfsync everysec`    异步操作，每秒记录，如果一秒内宕机，有数据丢失

+ 缺点：
	+ 相同数据集的数据而言aof文件要远大于rdb文件，恢复速度慢于rdb
	+ aof运行效率要慢于rdb,每秒同步策略效率较好，不同步效率和rdb相同

## 4、对比使用
-|-|-
对比 		| RDB 		| AOF
启动优先级	| 低 		| 高
体积			| 小 		| 大
恢复速度 		| 快 		| 慢
数据安全性 	| 会丢失数据	| 由策略决定
轻重 		| 重 		| 轻

+ aof和rdb功能同时存在时，redis重新启动的时候先加载aof保存的数据
+ 只做缓存：如果你只希望你的数据在服务器运行的时候存在,你也可以不使用任何持久化方式
+ 同时开启两种持久化方式：RDB的数据不实时，同时使用两者时服务器重启也只会找AOF文件